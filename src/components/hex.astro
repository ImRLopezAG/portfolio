---
export interface Props {
  class?: string;
  hexagonSize?: number;
  hexagonMargin?: number;
  hexagonClass?: string;
}

const {
  class: className = "",
  hexagonSize = 75,
  hexagonMargin = 3,
  hexagonClass = "",
} = Astro.props;

const hexagonWidth = hexagonSize;
const hexagonHeight = hexagonSize * 1.1;
const rowSpacing = hexagonSize * 0.8;
const baseMarginTop = -36 - 0.275 * (hexagonSize - 100);
const computedMarginTop = baseMarginTop + hexagonMargin;
const oddRowMarginLeft = -(hexagonSize / 2);
const evenRowMarginLeft = hexagonMargin / 2;
---

<div
  class:list={[
    "hexagon-background relative size-full overflow-hidden dark:bg-neutral-900 bg-neutral-100",
    className,
  ]}
  data-hexagon-size={hexagonSize}
  data-hexagon-margin={hexagonMargin}
  data-hexagon-width={hexagonWidth}
  data-hexagon-height={hexagonHeight}
  data-row-spacing={rowSpacing}
  data-computed-margin-top={computedMarginTop}
  data-odd-row-margin-left={oddRowMarginLeft}
  data-even-row-margin-left={evenRowMarginLeft}
  data-hexagon-class={hexagonClass}
>
  <div
    class="hexagon-grid absolute top-0 -left-0 size-full overflow-hidden"
    id="hexagon-grid"
  >
  </div>
  <slot />
</div>

<style is:global define:vars={{ hexagonMargin}}>
  
  
  .hexagon-background .hexagon-grid {
    margin-top: calc(var(--hexagonMargin) * -1);
  }
  .hexagon-background .hexagon-grid > div {
    margin-left: calc(var(--hexagonMargin) / 2);
  }
  .hexagon-background .hexagon-grid > div:nth-child(odd) {
    margin-left: calc(var(--hexagonMargin) * -1);
  }
  .hexagon-background .hexagon-grid > div:nth-child(even) {
    margin-left: calc(var(--hexagonMargin) / 2);
  }
</style>

<script
  define:vars={{
    hexagonSize,
    hexagonMargin,
    hexagonWidth,
    hexagonHeight,
    rowSpacing,
    computedMarginTop,
    oddRowMarginLeft,
    evenRowMarginLeft,
    hexagonClass,
  }}
  is:inline
>
  class HexagonBackground {
    constructor(element, config = {}) {
      this.element = element;
      this.gridContainer = element.querySelector("#hexagon-grid");
      this.gridDimensions = { rows: 0, columns: 0 };

      // Use passed config or fallback to data attributes or defaults
      this.hexagonSize = config.hexagonSize || parseInt(element.dataset.hexagonSize) || hexagonSize;
      this.hexagonMargin = config.hexagonMargin || parseInt(element.dataset.hexagonMargin) || hexagonMargin;
      this.hexagonWidth = config.hexagonWidth || parseInt(element.dataset.hexagonWidth) || hexagonWidth;
      this.hexagonHeight = config.hexagonHeight || parseInt(element.dataset.hexagonHeight) || hexagonHeight;
      this.rowSpacing = config.rowSpacing || parseFloat(element.dataset.rowSpacing) || rowSpacing;
      this.computedMarginTop = config.computedMarginTop || parseFloat(element.dataset.computedMarginTop) || computedMarginTop;
      this.oddRowMarginLeft = config.oddRowMarginLeft || parseFloat(element.dataset.oddRowMarginLeft) || oddRowMarginLeft;
      this.evenRowMarginLeft = config.evenRowMarginLeft || parseFloat(element.dataset.evenRowMarginLeft) || evenRowMarginLeft;
      this.hexagonClass = config.hexagonClass || element.dataset.hexagonClass || hexagonClass || "";

      // Update CSS variable if margin changes
      if (config.hexagonMargin) {
        document.documentElement.style.setProperty('--hexagon-margin', `${config.hexagonMargin}px`);
      }

      this.init();
    }

    init() {
      this.updateGridDimensions();
      this.renderGrid();

      // Add resize listener
      this.resizeHandler = () => {
        this.updateGridDimensions();
        this.renderGrid();
      };
      window.addEventListener("resize", this.resizeHandler);
    }

    updateGridDimensions() {
      const rows = Math.ceil(window.innerHeight / this.rowSpacing);
      const columns = Math.ceil(window.innerWidth / this.hexagonWidth) + 1;
      this.gridDimensions = { rows, columns };
    }

    renderGrid() {
      // Clear existing grid
      this.gridContainer.innerHTML = "";

      for (let rowIndex = 0; rowIndex < this.gridDimensions.rows; rowIndex++) {
        const row = document.createElement("div");
        row.className = "inline-flex";
        row.style.marginTop = `${this.computedMarginTop}px`;
        row.style.marginLeft = `${
          ((rowIndex + 1) % 2 === 0
            ? this.evenRowMarginLeft
            : this.oddRowMarginLeft) - 10
        }px`;

        for (
          let colIndex = 0;
          colIndex < this.gridDimensions.columns;
          colIndex++
        ) {
          const hexagon = document.createElement("div");

          // Build the className string with all Tailwind classes
          const hexagonClasses = [
            "relative",
            "[clip-path:polygon(50%_0%,_100%_25%,_100%_75%,_50%_100%,_0%_75%,_0%_25%)]",
            "before:content-['']",
            "before:absolute",
            "before:top-0",
            "before:left-0",
            "before:w-full",
            "before:h-full",
            "dark:before:bg-neutral-950",
            "before:bg-white",
            "before:opacity-100",
            "before:transition-all",
            "before:duration-1000",
            "after:content-['']",
            "after:absolute",
            "after:inset-[var(--hexagon-margin)]",
            "dark:after:bg-neutral-950",
            "after:bg-white",
            "after:[clip-path:polygon(50%_0%,_100%_25%,_100%_75%,_50%_100%,_0%_75%,_0%_25%)]",
            "hover:before:bg-neutral-200",
            "dark:hover:before:bg-neutral-800",
            "hover:before:opacity-100",
            "hover:before:duration-0",
            "dark:hover:after:bg-neutral-900",
            "hover:after:bg-neutral-100",
            "hover:after:opacity-100",
            "hover:after:duration-0",
          ];

          if (this.hexagonClass) {
            hexagonClasses.push(this.hexagonClass);
          }

          hexagon.className = hexagonClasses.join(" ");
          hexagon.style.width = `${this.hexagonWidth}px`;
          hexagon.style.height = `${this.hexagonHeight}px`;
          hexagon.style.marginLeft = `${this.hexagonMargin}px`;

          row.appendChild(hexagon);
        }

        this.gridContainer.appendChild(row);
      }
    }

    // Method to update configuration dynamically
    updateConfig(newConfig) {
      // Recalculate dependent values
      if (newConfig.hexagonSize) {
        this.hexagonSize = newConfig.hexagonSize;
        this.hexagonWidth = newConfig.hexagonSize;
        this.hexagonHeight = newConfig.hexagonSize * 1.1;
        this.rowSpacing = newConfig.hexagonSize * 0.8;
        const baseMarginTop = -36 - 0.275 * (newConfig.hexagonSize - 100);
        this.computedMarginTop = baseMarginTop + this.hexagonMargin;
        this.oddRowMarginLeft = -(newConfig.hexagonSize / 2);
        this.evenRowMarginLeft = this.hexagonMargin / 2;
      }

      if (newConfig.hexagonMargin !== undefined) {
        this.hexagonMargin = newConfig.hexagonMargin;
        document.documentElement.style.setProperty('--hexagon-margin', `${newConfig.hexagonMargin}px`);
        
        // Recalculate margins if size wasn't changed
        if (!newConfig.hexagonSize) {
          const baseMarginTop = -36 - 0.275 * (this.hexagonSize - 100);
          this.computedMarginTop = baseMarginTop + this.hexagonMargin;
          this.evenRowMarginLeft = this.hexagonMargin / 2;
        }
      }

      if (newConfig.hexagonClass !== undefined) {
        this.hexagonClass = newConfig.hexagonClass;
      }

      // Re-render grid with new configuration
      this.updateGridDimensions();
      this.renderGrid();
    }

    // Cleanup method
    destroy() {
      if (this.resizeHandler) {
        window.removeEventListener("resize", this.resizeHandler);
      }
    }
  }

  // Store instances globally for external access
  window.hexagonBackgroundInstances = window.hexagonBackgroundInstances || new Map();

  // Initialize all hexagon backgrounds
  function initializeHexagonBackgrounds() {
    const hexagonBackgrounds = document.querySelectorAll(".hexagon-background");
    hexagonBackgrounds.forEach((element) => {
      // Avoid double initialization
      if (!window.hexagonBackgroundInstances.has(element)) {
        const instance = new HexagonBackground(element);
        window.hexagonBackgroundInstances.set(element, instance);
      }
    });
  }

  // Global utility functions for external control
  window.updateHexagonBackground = function(selector, config) {
    const element = document.querySelector(selector);
    if (element && window.hexagonBackgroundInstances.has(element)) {
      window.hexagonBackgroundInstances.get(element).updateConfig(config);
    }
  };

  window.updateAllHexagonBackgrounds = function(config) {
    window.hexagonBackgroundInstances.forEach(instance => {
      instance.updateConfig(config);
    });
  };

  document.addEventListener("DOMContentLoaded", initializeHexagonBackgrounds);
  document.addEventListener("astro:page-load", initializeHexagonBackgrounds);
</script>